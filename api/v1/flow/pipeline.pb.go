// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: v1/flow/pipeline.proto

package flow

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Source 数据存储源
type Source struct {
	Id       int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	Type     string `protobuf:"bytes,2,opt,name=type,proto3" json:"type" gorm:"type:varchar(20);not null;comment:es、mysql、zinc"`
	Host     string `protobuf:"bytes,3,opt,name=host,proto3" json:"host" gorm:"type:varchar(100);not null;comment:主机ip"`
	Port     int32  `protobuf:"varint,4,opt,name=port,proto3" json:"port" gorm:"comment:端口"`
	Username string `protobuf:"bytes,5,opt,name=username,proto3" json:"username" gorm:"type:varchar(50);comment:数据库用户名"`
	Password string `protobuf:"bytes,6,opt,name=password,proto3" json:"password" gorm:"type:varchar(50);not null;comment:数据库密码"`
	Remark   string `protobuf:"bytes,7,opt,name=remark,proto3" json:"remark" gorm:"type:text;comment:备注"`
}

func (m *Source) Reset()         { *m = Source{} }
func (m *Source) String() string { return proto.CompactTextString(m) }
func (*Source) ProtoMessage()    {}
func (*Source) Descriptor() ([]byte, []int) {
	return fileDescriptor_00d7fedb7555fa10, []int{0}
}
func (m *Source) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Source) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Source.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Source) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Source.Merge(m, src)
}
func (m *Source) XXX_Size() int {
	return m.Size()
}
func (m *Source) XXX_DiscardUnknown() {
	xxx_messageInfo_Source.DiscardUnknown(m)
}

var xxx_messageInfo_Source proto.InternalMessageInfo

func (m *Source) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Source) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *Source) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *Source) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Source) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *Source) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *Source) GetRemark() string {
	if m != nil {
		return m.Remark
	}
	return ""
}

// Sink 数据存储
type Sink struct {
	Id        int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	SinkId    string `protobuf:"bytes,8,opt,name=sink_id,json=sinkId,proto3" json:"sink_id" gorm:"type:varchar(32);unique;not null;comment:sink_id"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name" gorm:"type:varchar(50);not null;comment:sink名称"`
	SourceId  int32  `protobuf:"varint,3,opt,name=source_id,json=sourceId,proto3" json:"source_id" gorm:"type:varchar(100);comment:外键ID"`
	DbName    string `protobuf:"bytes,4,opt,name=db_name,json=dbName,proto3" json:"db_name" gorm:"type:varchar(100);comment:数据库"`
	TableName string `protobuf:"bytes,5,opt,name=table_name,json=tableName,proto3" json:"db_table" gorm:"type:varchar(100);comment:数据表"`
	Remark    string `protobuf:"bytes,6,opt,name=remark,proto3" json:"remark" gorm:"type:text;comment:备注"`
	// 必须指定一个source源
	Source *Source `protobuf:"bytes,7,opt,name=source,proto3" json:"sink_source" gorm:"foreignKey:source_id"`
}

func (m *Sink) Reset()         { *m = Sink{} }
func (m *Sink) String() string { return proto.CompactTextString(m) }
func (*Sink) ProtoMessage()    {}
func (*Sink) Descriptor() ([]byte, []int) {
	return fileDescriptor_00d7fedb7555fa10, []int{1}
}
func (m *Sink) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Sink) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Sink.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Sink) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Sink.Merge(m, src)
}
func (m *Sink) XXX_Size() int {
	return m.Size()
}
func (m *Sink) XXX_DiscardUnknown() {
	xxx_messageInfo_Sink.DiscardUnknown(m)
}

var xxx_messageInfo_Sink proto.InternalMessageInfo

func (m *Sink) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Sink) GetSinkId() string {
	if m != nil {
		return m.SinkId
	}
	return ""
}

func (m *Sink) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Sink) GetSourceId() int32 {
	if m != nil {
		return m.SourceId
	}
	return 0
}

func (m *Sink) GetDbName() string {
	if m != nil {
		return m.DbName
	}
	return ""
}

func (m *Sink) GetTableName() string {
	if m != nil {
		return m.TableName
	}
	return ""
}

func (m *Sink) GetRemark() string {
	if m != nil {
		return m.Remark
	}
	return ""
}

func (m *Sink) GetSource() *Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func init() {
	proto.RegisterType((*Source)(nil), "api.v1.flow.Source")
	proto.RegisterType((*Sink)(nil), "api.v1.flow.Sink")
}

func init() { proto.RegisterFile("v1/flow/pipeline.proto", fileDescriptor_00d7fedb7555fa10) }

var fileDescriptor_00d7fedb7555fa10 = []byte{
	// 698 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x94, 0xc1, 0x6b, 0x13, 0x41,
	0x14, 0xc6, 0xbb, 0xe9, 0x76, 0x9b, 0x4e, 0x3d, 0xad, 0x58, 0x16, 0x85, 0x9d, 0x3a, 0xa7, 0x46,
	0x30, 0x6d, 0x53, 0x8a, 0x36, 0x01, 0x85, 0xa0, 0x62, 0x11, 0x44, 0xa6, 0x07, 0xb1, 0x82, 0x61,
	0x93, 0x9d, 0xa6, 0x4b, 0x93, 0x9d, 0xed, 0xee, 0xa6, 0xb5, 0x9e, 0xda, 0x8b, 0x7a, 0x29, 0x16,
	0xac, 0x9e, 0x3c, 0x28, 0x0a, 0x16, 0x84, 0xb6, 0xe0, 0x41, 0xa9, 0xff, 0x80, 0xc7, 0x1e, 0x3d,
	0x0d, 0xda, 0x98, 0x44, 0x73, 0xdc, 0x93, 0x47, 0x99, 0xd9, 0x74, 0x1b, 0x68, 0x82, 0x05, 0x2f,
	0xcb, 0xce, 0x9b, 0x79, 0xbf, 0xf9, 0xde, 0xbc, 0x8f, 0x07, 0x86, 0x96, 0xc6, 0x47, 0xe7, 0x4a,
	0x74, 0x79, 0xd4, 0xb1, 0x1c, 0x52, 0xb2, 0x6c, 0x92, 0x74, 0x5c, 0xea, 0x53, 0x75, 0xd0, 0x70,
	0xac, 0xe4, 0xd2, 0x78, 0x92, 0xef, 0x9d, 0xd5, 0x44, 0x2c, 0x5f, 0x99, 0x1b, 0x2d, 0xd2, 0x22,
	0x15, 0x9f, 0xf0, 0x18, 0xda, 0x94, 0x81, 0x32, 0x43, 0x2b, 0x6e, 0x81, 0xa8, 0x43, 0x20, 0x66,
	0x99, 0x9a, 0x34, 0x2c, 0x8d, 0xf4, 0x65, 0x95, 0x26, 0x83, 0x31, 0xcb, 0xc4, 0x31, 0xcb, 0x54,
	0x67, 0x81, 0xec, 0xaf, 0x38, 0x44, 0x8b, 0x0d, 0x4b, 0x23, 0x03, 0xd9, 0x1b, 0x4d, 0x06, 0xc5,
	0x3a, 0x60, 0x30, 0x5d, 0xa4, 0x6e, 0x39, 0x8d, 0xf8, 0x2a, 0xbd, 0x64, 0xb8, 0x85, 0x79, 0xc3,
	0x1d, 0x49, 0x8d, 0x25, 0x32, 0x36, 0xf5, 0x87, 0xed, 0x4a, 0xa9, 0x94, 0x29, 0xd0, 0x72, 0x99,
	0xd8, 0x7e, 0x9a, 0x78, 0xd5, 0xd5, 0xb5, 0xf2, 0x8a, 0xb7, 0x58, 0xaa, 0xae, 0xae, 0x3d, 0xb2,
	0xec, 0x02, 0xc2, 0x82, 0xa1, 0x62, 0x20, 0xcf, 0x53, 0xcf, 0xd7, 0x7a, 0x05, 0xfb, 0x0a, 0x67,
	0xf3, 0x75, 0xc0, 0x60, 0xaa, 0x03, 0x7b, 0x7c, 0xac, 0x13, 0xfc, 0xe7, 0xe7, 0x2f, 0xf5, 0x57,
	0x7b, 0x96, 0x83, 0xb0, 0xc8, 0x55, 0x27, 0x81, 0xec, 0x50, 0xd7, 0xd7, 0x64, 0x51, 0xc9, 0x79,
	0xce, 0xe4, 0xeb, 0x80, 0xc1, 0x33, 0x21, 0xf3, 0x30, 0xb1, 0xf1, 0x61, 0xa7, 0xf6, 0xec, 0x2d,
	0xc2, 0x62, 0x5b, 0x7d, 0x00, 0xe2, 0x15, 0x8f, 0xb8, 0xb6, 0x51, 0x26, 0x5a, 0x9f, 0x90, 0x93,
	0x6d, 0x32, 0x18, 0xc5, 0xba, 0x48, 0x9a, 0x1c, 0x4b, 0x44, 0x42, 0xea, 0x2f, 0x76, 0xeb, 0xeb,
	0xdb, 0xb5, 0xbd, 0xe7, 0x8d, 0xcd, 0xad, 0xfa, 0xd3, 0x4f, 0xb5, 0x8d, 0x75, 0x84, 0xa3, 0x7c,
	0xd5, 0x04, 0x71, 0xc7, 0xf0, 0xbc, 0x65, 0xea, 0x9a, 0x9a, 0x22, 0xf8, 0x37, 0x39, 0xff, 0x30,
	0x16, 0x30, 0x78, 0xb9, 0x0b, 0xff, 0x58, 0xc5, 0xd1, 0x45, 0xb5, 0x9d, 0xc7, 0x8d, 0xd7, 0x6b,
	0x08, 0x47, 0x14, 0xf5, 0x3a, 0x50, 0x5c, 0x52, 0x36, 0xdc, 0x05, 0xad, 0x5f, 0xdc, 0x71, 0xb1,
	0xc9, 0x60, 0x2b, 0x12, 0x30, 0x08, 0xdb, 0x6e, 0xf0, 0xc9, 0x43, 0x3f, 0x22, 0xd6, 0xde, 0x3d,
	0xa9, 0x7f, 0xdc, 0x42, 0xb8, 0x75, 0x14, 0xad, 0xf6, 0x01, 0x79, 0xc6, 0xb2, 0x17, 0xba, 0x9a,
	0x22, 0x07, 0xfa, 0x3d, 0xcb, 0x5e, 0xc8, 0x59, 0xa6, 0x16, 0x8f, 0x7c, 0x71, 0x18, 0x0a, 0x18,
	0xbc, 0xd4, 0xa1, 0x96, 0x89, 0x54, 0x22, 0x53, 0xb1, 0xad, 0xc5, 0x0a, 0x39, 0x5e, 0x52, 0x2b,
	0x13, 0x61, 0x85, 0xff, 0x4d, 0x9b, 0xea, 0x0c, 0x90, 0x45, 0x2b, 0x42, 0xd7, 0x5d, 0xe5, 0x5d,
	0x6c, 0xb5, 0x61, 0xe2, 0xa4, 0xcf, 0xc4, 0x49, 0xb5, 0x8d, 0xf5, 0xc6, 0xfb, 0x5d, 0x84, 0x45,
	0xb2, 0x7a, 0x17, 0x0c, 0x78, 0xc2, 0xec, 0x5c, 0x77, 0xaf, 0x28, 0x2a, 0xdd, 0x64, 0xf0, 0x28,
	0x18, 0x30, 0x98, 0xe8, 0x66, 0xbc, 0xa3, 0xb7, 0x7a, 0xf9, 0x7b, 0x73, 0x7b, 0xfa, 0x1a, 0xc2,
	0xf1, 0x30, 0x6f, 0xda, 0x54, 0x31, 0xe8, 0x37, 0xf3, 0x39, 0x21, 0x58, 0x16, 0x82, 0xa7, 0xf8,
	0x73, 0xb4, 0x42, 0x01, 0x83, 0x17, 0xfe, 0x05, 0x8d, 0x5a, 0x8a, 0xb0, 0x62, 0xe6, 0x6f, 0x73,
	0xb1, 0xf7, 0x00, 0xf0, 0x8d, 0x7c, 0x89, 0xe4, 0xda, 0x2c, 0xc9, 0xd5, 0xc6, 0xcd, 0x7c, 0x4e,
	0x6c, 0x9c, 0x9c, 0xfb, 0xeb, 0xcd, 0x16, 0xc2, 0x03, 0x22, 0x49, 0xa0, 0x8f, 0x5c, 0xa2, 0xfc,
	0x87, 0x4b, 0xd4, 0xfb, 0x40, 0x09, 0x5f, 0x40, 0x98, 0x6d, 0x30, 0x75, 0x3a, 0xd9, 0x36, 0x74,
	0x92, 0xe1, 0x58, 0xc9, 0x26, 0x9b, 0x0c, 0x0e, 0x8a, 0xf6, 0x86, 0x67, 0x03, 0x06, 0xcf, 0x85,
	0x17, 0xcc, 0x51, 0x97, 0x58, 0x45, 0xfb, 0x16, 0x59, 0x49, 0x47, 0x0d, 0xe0, 0x06, 0x08, 0xf3,
	0xa6, 0xfe, 0xfc, 0xd0, 0xa5, 0xaf, 0x07, 0xba, 0xb4, 0x7f, 0xa0, 0x4b, 0xdf, 0x0f, 0x74, 0x69,
	0xa3, 0xaa, 0xf7, 0xec, 0x57, 0xf5, 0x9e, 0x6f, 0x55, 0xbd, 0x07, 0xb4, 0x8f, 0xb7, 0x3b, 0xd2,
	0xec, 0xa9, 0xd6, 0x14, 0xcc, 0xf0, 0x4f, 0x5e, 0x11, 0xb3, 0x6d, 0xe2, 0x6f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x11, 0x95, 0x04, 0x6d, 0x1c, 0x05, 0x00, 0x00,
}

func (m *Source) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Source) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Source) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Remark) > 0 {
		i -= len(m.Remark)
		copy(dAtA[i:], m.Remark)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Remark)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Password) > 0 {
		i -= len(m.Password)
		copy(dAtA[i:], m.Password)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Password)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Port != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Sink) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Sink) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Sink) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SinkId) > 0 {
		i -= len(m.SinkId)
		copy(dAtA[i:], m.SinkId)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.SinkId)))
		i--
		dAtA[i] = 0x42
	}
	if m.Source != nil {
		{
			size, err := m.Source.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPipeline(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Remark) > 0 {
		i -= len(m.Remark)
		copy(dAtA[i:], m.Remark)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Remark)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.TableName) > 0 {
		i -= len(m.TableName)
		copy(dAtA[i:], m.TableName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.TableName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DbName) > 0 {
		i -= len(m.DbName)
		copy(dAtA[i:], m.DbName)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.DbName)))
		i--
		dAtA[i] = 0x22
	}
	if m.SourceId != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.SourceId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintPipeline(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintPipeline(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPipeline(dAtA []byte, offset int, v uint64) int {
	offset -= sovPipeline(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func NewPopulatedSource(r randyPipeline, easy bool) *Source {
	this := &Source{}
	this.Id = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Id *= -1
	}
	this.Type = string(randStringPipeline(r))
	this.Host = string(randStringPipeline(r))
	this.Port = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Port *= -1
	}
	this.Username = string(randStringPipeline(r))
	this.Password = string(randStringPipeline(r))
	this.Remark = string(randStringPipeline(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

func NewPopulatedSink(r randyPipeline, easy bool) *Sink {
	this := &Sink{}
	this.Id = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Id *= -1
	}
	this.Name = string(randStringPipeline(r))
	this.SourceId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.SourceId *= -1
	}
	this.DbName = string(randStringPipeline(r))
	this.TableName = string(randStringPipeline(r))
	this.Remark = string(randStringPipeline(r))
	if r.Intn(5) != 0 {
		this.Source = NewPopulatedSource(r, easy)
	}
	this.SinkId = string(randStringPipeline(r))
	if !easy && r.Intn(10) != 0 {
	}
	return this
}

type randyPipeline interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RunePipeline(r randyPipeline) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringPipeline(r randyPipeline) string {
	v1 := r.Intn(100)
	tmps := make([]rune, v1)
	for i := 0; i < v1; i++ {
		tmps[i] = randUTF8RunePipeline(r)
	}
	return string(tmps)
}
func randUnrecognizedPipeline(r randyPipeline, maxFieldNumber int) (dAtA []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		dAtA = randFieldPipeline(dAtA, r, fieldNumber, wire)
	}
	return dAtA
}
func randFieldPipeline(dAtA []byte, r randyPipeline, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		dAtA = encodeVarintPopulatePipeline(dAtA, uint64(key))
		v2 := r.Int63()
		if r.Intn(2) == 0 {
			v2 *= -1
		}
		dAtA = encodeVarintPopulatePipeline(dAtA, uint64(v2))
	case 1:
		dAtA = encodeVarintPopulatePipeline(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		dAtA = encodeVarintPopulatePipeline(dAtA, uint64(key))
		ll := r.Intn(100)
		dAtA = encodeVarintPopulatePipeline(dAtA, uint64(ll))
		for j := 0; j < ll; j++ {
			dAtA = append(dAtA, byte(r.Intn(256)))
		}
	default:
		dAtA = encodeVarintPopulatePipeline(dAtA, uint64(key))
		dAtA = append(dAtA, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return dAtA
}
func encodeVarintPopulatePipeline(dAtA []byte, v uint64) []byte {
	for v >= 1<<7 {
		dAtA = append(dAtA, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	dAtA = append(dAtA, uint8(v))
	return dAtA
}
func (m *Source) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPipeline(uint64(m.Id))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPipeline(uint64(m.Port))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	return n
}

func (m *Sink) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPipeline(uint64(m.Id))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.SourceId != 0 {
		n += 1 + sovPipeline(uint64(m.SourceId))
	}
	l = len(m.DbName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.TableName)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.Remark)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovPipeline(uint64(l))
	}
	l = len(m.SinkId)
	if l > 0 {
		n += 1 + l + sovPipeline(uint64(l))
	}
	return n
}

func sovPipeline(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPipeline(x uint64) (n int) {
	return sovPipeline(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Source) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Source: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Source: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Sink) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Sink: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Sink: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			m.SourceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SourceId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DbName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DbName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TableName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TableName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remark", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Remark = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Source{}
			}
			if err := m.Source.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SinkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPipeline
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPipeline
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SinkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPipeline(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPipeline
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPipeline(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPipeline
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPipeline
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPipeline
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPipeline
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPipeline
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPipeline        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPipeline          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPipeline = fmt.Errorf("proto: unexpected end of group")
)
